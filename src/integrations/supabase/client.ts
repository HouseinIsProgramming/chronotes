
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://kotlquhcezutnohcovie.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtvdGxxdWhjZXp1dG5vaGNvdmllIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDUwMzQyNzIsImV4cCI6MjA2MDYxMDI3Mn0.A8WkCaaraiNLVqmIOJLkecptrQq46LNRdLR8-aIqlEg";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Retry utility for Supabase operations
export async function withRetry<T>(
  operation: () => Promise<{ data: T | null; error: any }> | any,
  maxRetries = 3,
  delay = 1000
): Promise<{ data: T | null; error: any }> {
  let retries = 0;
  let lastError: any = null;

  while (retries < maxRetries) {
    try {
      // Handle both Promise and PostgrestBuilder (which has .then but isn't a full Promise)
      const result = await operation();
      
      // Check if the result has the expected structure
      if ('error' in result) {
        if (!result.error) {
          return result; // Success - return the result
        }
        
        lastError = result.error;
        
        // Don't retry certain errors
        if (result.error.code === '22P02' || // Invalid syntax (likely client-side issue)
            result.error.code === '42P01' || // Undefined table (likely schema issue)
            result.error.code === '42703') { // Undefined column (likely schema issue)
          return result;
        }
      } else {
        // If it doesn't have the expected error property, assume success
        return { data: result as T, error: null };
      }
      
    } catch (error) {
      lastError = error;
    }

    retries++;
    console.log(`Operation failed, retrying (${retries}/${maxRetries})...`);
    
    // Wait before retry
    await new Promise(resolve => setTimeout(resolve, delay));
    
    // Increase delay for next retry (exponential backoff)
    delay *= 2;
  }

  // All retries failed
  return { data: null, error: lastError };
}
